#include <iostream> // IMPORTAREMOS ESTA LIBRERÍA (MUY IMPORTANTE!!!!!)
#include "Print.h" // LIBRERÍA DE UNA CLASE EN LA CUÁL DEBEMOS DE IMPORTARLA.

// EN ESTA CLASE DEL MAIN UTILIZAREMOS ESPACIO DE NOMBRES.

using namespace std;

// VAMOS A TRABAJAR CON ALGUNAS DE SUS FUNCIONES EN ESTA SECCIÓN DEL MENÚ...

void funcion1(long long* a)
{
    // PRIMERA FUNCIÓN QUE UTILIZA COMO VARIABLE UNA INCÓGNITA YA DECLARADA CON UN PUNTERO...

    (*a)--; // DISMINUYE EL VALOR DE SU INCÓGNITA.

    // IMPRIME UN MENSAJE MEDIANTE DECLARACIÓN DE VARIABLES MÁS UN ESPACIO DE NOMBRES POR CONSOLA DE DEPURACIÓN...

    // std::cout << *a << " : 3 = " << 3 << std::endl; // PARA PODER LEER BIEN EL RESULTADO POR PANTALLA, UTILIZAREMOS UN SALTO DE LÍNEA.
    // std::cout << 0;

    // return (*a); // RETORNA EL VALOR DISMINUIDO DE SU INCÓGNITA.
}

void funcion2(int a)
{
    // SEGUNDA FUNCIÓN QUE UTILIZA COMO VARIABLE UNA INCÓGNITA YA DECLARADA NORMALMENTE...

    a--; // DISMINUYE EL VALOR DE SU INCÓGNITA.
    // return a; // RETORNA EL VALOR DISMINUIDO DE SU INCÓGNITA.
}

void funcion3(const char* str)
{
    // TERCERA FUNCIÓN DE PRUEBA CON UNA SOLA VARIABLE LOCAL...

    Print(str);
}

int main()
{
    // ESTA ES LA CLASE DEL MAIN POR DEFECTO.

    // AQUÍ EN ESTE PROYECTO PROBAREMOS CON DIRECCIONES DE MEMORIA POR CADA 2 BYTES...

    int a = 14; // VARIABLE PRINCIPAL DE PRUEBA.
    cout << &a << endl; // DIRECCIONES DE MEMORIA MEDIANTE ESTA VARIABLE.
    int* a_dir = &a; // LA VARIABLE SECUENCIAL SE TRABAJA CON UN PUNTERO QUE APUNTE DICHA DIRECCIÓN DE MEMORIA.

    // COMO TODO ESTÁ COMENTADO DENTRO DE ESTA FUNCIÓN, VAMOS A PASAR UN ARREGLO COMPLETO DE CADA VECTOR EN NÚMEROS ENTEROS...

    /*
    cout << "int: " << sizeof(int) << endl; // DEVUELVE UN ENTERO EN EL PRIMER VECTOR.
    cout << "long: " << sizeof(long) << endl; // DEVUELVE UN VALOR GRANDE EN EL SEGUNDO VECTOR.
    cout << "long long: " << sizeof(long long) << endl; // DEVUELVE UN VALOR MUY GRANDE Y DISTANCIADO EN EL TERCER VECTOR.
    cout << "bool: " << sizeof(bool) << endl; // DEVUELVE UN BOOLEANO EN EL CUARTO VECTOR.
    cout << "char: " << sizeof(char) << endl; // DEVUELVE UN SÓLO CARÁCTER EN EL QUINTO VECTOR.
    cout << "string: " << sizeof(string) << endl; // DEVUELVE UNA CADENA DE CARACTERES EN EL SEXTO VECTOR.
    cout << "float: " << sizeof(float) << endl; // DEVUELVE UN VALOR FLOTANTE (APROXIMACIÓN NUMÉRICA) EN EL SÉPTIMO VECTOR.
    cout << "double: " << sizeof(double) << endl; // DEVUELVE UN VALOR EN DECIMAL EN EL OCTAVO VECTOR.
    */

    // CREAREMOS UN ARREGLO MEDIANTE UN VECTOR CON 10 ELEMENTOS EN TOTAL.

    // long long vector[10];

    // LUEGO, LO INICIALIZAREMOS CON DICHO ARREGLO...

    // vector[0] = 10;

    // REALIZAREMOS OPERACIONES ALGEBRAICAS EN ESTE MÉTODO.

    // int x = 4; // "x" ES IGUAL A 4.
    /* x++; // INCREMENTA SU VALOR AL PRINCIPIO DE ESTA VARIABLE YA DECLARADA.
    int y = 8; // "y" ES IGUAL A 8.

    // PARA PRACTICAR UN POCO CON ESTE LENGUAJE DE PROGRAMACIÓN, VAMOS A CREAR UN CICLO "for".

    for (int i = 0; i < 10; i++) // LOS NÚMEROS YA DECLARADOS EN ESTA ITERACIÓN ESTARÁN ENTRE EL 0 Y EL 9.
    {
        y++; // INCREMENTA SU VALOR EN "y".
    }
    */

    // COMO TODO LO DEMÁS YA ESTÁ COMENTADO, VAMOS A EJECUTAR LOS SIGUIENTES MÉTODOS AQUÍ, UTILIZANDO UNA VARIABLE DECLARADA AHÍ ARRIBA...

    /*
    funcion1(vector); // CON ESTE PUNTERO NO DEVUELVE NINGÚN VALOR EN X, YA QUE DICHO PUNTERO ASOCIADO ES UNA CONSTANTE.
    cout << vector << endl; // CON UN ESPACIO DE NOMBRES, LEEREMOS EL MENSAJE FÁCILMENTE MEDIANTE ESTA LÍNEA DE CÓDIGO.
    */

    // PARA LEER EL ARREGLO COMPLETO MEDIANTE DIRECCIONES DE MEMORIA EN CADA VECTOR, UTILIZAREMOS UN CICLO "for"...

    /*

    for (int i = 0; i < 10; i++)
    {
        cout << &vector[i] << endl; // LAS DIRECCIONES DE MEMORIA PRINTEADAS POR PANTALLA SE LEEN EN CADA LÍNEA DE LA CONSOLA (9 ELEMENTOS)...
    }

    // funcion2(x); // ÉSTE SÍ DEVUELVE UN VALOR.

    */

    funcion3("**************ERRORES DE COMPILACION!!!!!!!**************");
};
